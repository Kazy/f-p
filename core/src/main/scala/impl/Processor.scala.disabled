package silt
package impl
package netty

import java.util.concurrent.{ BlockingQueue, LinkedBlockingQueue }

import io.netty.util.ReferenceCountUtil

import com.typesafe.scalalogging.{ StrictLogging => Logging }

/** Execute [[silt.impl.netty.Server server]]'s event loop.
  *
  * @param mq Message queue incomming messages are forwared to.
  */
private[netty] class Processor extends AnyRef with silt.Processor with Logging /*with SendUtils*/ {

  def process(question: silt.Message): Unit = // XXX Future[silt.Message]
    ???

  private val mq = new LinkedBlockingQueue[silt.Message]()

  def start(): Unit = {
    logger.debug("Receptor start ...")

    //worker.setName(s"Receptor of ${system.name}")
    worker.setDaemon(true)
    worker.start()

    logger.debug("Receptor start done.")
  }

  def stop(): Unit = {
    logger.debug("Receptor stop ...")

    terminate = true
    worker.interrupt()
    worker.join()

    logger.debug("Receptor stop done.")
  }

  //def add(msg: Incoming): Boolean =
  //  mq add msg

  @volatile private var terminate = false

  private val worker = new Thread {

    override def run(): Unit =
      while (!terminate) try mq.take() match {
        //case l: HandleIncomingLocal => handleIncomingLocal(l.msg, l.ctx, l.resultPromise)
        //case Incoming(msg, ctx) => handleIncoming(msg, ctx)
        case _                  => // XXX: unexpected object in queue.
      } catch { case _: InterruptedException => /* continue to check `terminate` */ }

  }

  //private def handleIncoming(ctx: ChannelHandlerContext, msg: Any): Unit = {
  //  //val in = msg.asInstanceOf[ByteBuf]
  //  //val bos = new ByteArrayOutputStream

  //  try {
  //    //while (in.isReadable()) bos.write(in.readByte().asInstanceOf[Int])
  //  } finally {
  //    ReferenceCountUtil.release(msg)
  //  }

  //}

}

// vim: set tw=80 ft=scala:
